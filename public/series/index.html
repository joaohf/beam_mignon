<!doctype html><html lang=pt-br><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>BEAM Mignon</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="A blog about Erlang and Elixir ecosystem."><meta name=generator content="Hugo 0.105.0-DEV"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><link href=/series/feed.xml rel=alternate type=application/rss+xml title="BEAM Mignon"><link href=/series/feed.xml rel=feed type=application/rss+xml title="BEAM Mignon"><meta property="og:title" content="Series"><meta property="og:description" content="A blog about Erlang and Elixir ecosystem."><meta property="og:type" content="website"><meta property="og:url" content="https://beam-mignon.netlify.app/series/"><meta itemprop=name content="Series"><meta itemprop=description content="A blog about Erlang and Elixir ecosystem."><meta name=twitter:card content="summary"><meta name=twitter:title content="Series"><meta name=twitter:description content="A blog about Erlang and Elixir ecosystem."></head><body class="ma0 avenir bg-near-white"><header><div class="pb3-m pb6-l bg-black"><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">BEAM Mignon</a><div class="flex-l items-center"><h4></h4><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/en/series/>en</a></li></ul><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/contact/ title="Contato page">Contato</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/posts/ title="Posts page">Posts</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/reference/ title="Referencias page">Referencias</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/about/ title="Sobre page">Sobre</a></li></ul><div class=ananke-socials><a href=https://twitter.com/joaohf target=_blank class="twitter ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window"><span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span></a><a href=https://github.com/joaohf/ target=_blank class="github ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel=noopener aria-label="follow on GitHub——Opens in a new window"><span class=icon><svg style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span></a><a href=https://www.linkedin.com/in/jo%c3%a3o-henrique-freitas target=_blank class="linkedin ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="LinkedIn link" rel=noopener aria-label="follow on LinkedIn——Opens in a new window"><span class=icon><svg style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span></a><a href=https://beam-mignon.netlify.app/feed.xml target=_blank class="rss ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="RSS link" rel=noopener aria-label="follow on RSS——Opens in a new window"><span class=icon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"/><path id="scale" d="M4 4.44v2.83c7.03.0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9.0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span></a></div></div></div></nav><div class="tc-l pv3 ph3 ph4-ns"><h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">Series</h1></div></div></header><main class=pb7 role=main><article class="cf pa3 pa4-m pa4-l"><div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links mid-gray"></div></article><div class="mw8 center"><section class=ph4><h2 class=f1><a href=/series/101/ class="link blue hover-black">Series: 101</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-35/ class="link black dim">Criando parser para arquivos texto</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Parseando Imagine a situação na qual o seu programa precisa ler arquivos texto no qual o conteúdo está em um formato adhoc ou muito criativo e você não tem ideia de como implementar o parser do arquivo. Muitas vezes até sabemos como implementar mas é uma tarefa tediosa. Outras vezes tentamos fugir da implementação.
A verdade é que precisamos conhecer as ferramentas para melhor sair das situações. Nesse post vamos percorrer alguns possíveis caminhos para implementar alguns parses de arquivos.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-31/ class="link black dim">Aplicações distribuídas com OTP</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Distributed applications O conceito de distributed applications em Erlang/OTP segue a ideia de que determinada aplicação executa em um determinado nó de um cluster. Se a aplicação parar por alguma falha, então a aplicação vai ser iniciada em outro nó.
Isso não quer dizer que a aplicação vai estar rodando em todos os nós ao mesmo tempo. Mas sim em apenas um determinado nó (de maior prioridade configurada).
O que vai estar rodando e ativamente controlando a aplicação é o _distributed application controller.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-30/ class="link black dim">mermaid com edoc ou ex_docs</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Documentar o código é parte do processo de design e implementação de um software. Ajuda a clarear a mente, ordenar conceitos e passos. Além de induzir os questionamento e também simplificação de código.
Em muitos projetos e times, documentar é preciso pois não se sabe como vai ser a configuração do time ao médio e longo prazo. Pode ser que novos integrantes entrem e os mais antigos sejam deslocados para outras funções e com eles boa parte do conhecimento.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-14/ class="link black dim">Opções para repositório de pacotes hex.pm</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Quando desenvolvemos em Elixir ou Erlang, de forma open source, geralmente publicamos o código em um repositório de código público e também divulgamos no hex.pm para que outros usuários possam encontrar e usar.
Mas como podemos tornar o processo de publicação eficiente dentro de uma empresa ? A seguir, algumas formas de resolver.
Em diversas empresas, após construir alguns códigos, isolar em funcionalidades específicas e transformar em bibliotecas Elixir ou Erlang.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-13/ class="link black dim">Erlang Ecosystem Foundation</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Este post é uma pequena nota sobre Erlang Ecosystem Foundation. Basicamente é uma organização sem fins lucrativos onde um conjunto de membros trabalham em diversos grupos de trabalho.
Os seguintes grupos de trabalho foram definidos inicialmente:
Marketing Fellowship Security Observability Sponsorship Erlang Ecosystem Foundation Building and Packaging Education, Training, & Adoption Documentation Qualquer pessoa ou empresa pode fazer parte da EEF gratuitamente. Podendo, se quiser, fazer doações de horas trabalhando em determinados projetos de algum grupo de trabalho ou ajudando financeiramente a EFF.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-10/ class="link black dim">Erlang: bad parts</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Alguns comentários sobre as questões contidas nesta apresentação On Network Configuration, Distributed and Concurrent Programming with Erlang Chalmers sobre o tema &ldquo;Erlang bad parts&rdquo;:
The syntax
Pessoalmente, eu acho a sintaxe da linguagem (tanto Erlang quanto Elixir) bem prática. Mas ao mesmo tempo, se você comparar com qualquer outra linguagem (exemplo: C ou Javascript) vai notar algumas construções esquisitas.
Mas, depois de um tempo tudo fica confortável e prático. A dica aqui é não focar na sintaxe, busque entender o paradigma funcional e como a sintaxe ajuda nisso.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-2/ class="link black dim">Como vejo a BEAM VM</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">BEAM VM BEAM VM é o nome formal da máquina virtual no qual algumas linguagens de programação utilizam para executar as instruções de um programa.
As principais linguagens são: Erlang e Elixir. Mas existem outras:
luerl efene clojerl Erlang Erlang github https://www.erlang.org/ Jira É uma linguagem de programação funcional com primitivas de concorrência integrados na linguagem.
Geralmente os programas são organizados em módulos contendo funções privadas e públicas. Eu gosto de comparar com programas escritos em linguagem C (apesar do paradigma ser bem diferente, a estrutura e organização é similar, ou seja, funções e módulos).</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-1/ class="link black dim">No Meio do Caminho tinha uma pedra</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Como conheci Erlang/OTP Tudo começou em 2009 quando estava procurando alguma biblioteca opensource já pronto e testado para um protocolo chamado MEGACO, H.248. Após algumas pesquisas encontrei algo sobre Erlang, mas não tinha entendido nada e muito menos como integrar com o trabalho que tinha que fazer utilizando linguagem C em uma plataforma embarcada. Então abandonei a ideia mas mantive o nome da linguagem na lista de coisas para estudar.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-0/ class="link black dim">Introdução do BEAM Mignon</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Um blog em português A ideia inicial é construir algum tipo de documentação em Português, com links e referências interessantes nas quais possam ser utilizadas no futuro.
De fato não há muita documentação sobre Erlang e Elixir em português. Fico pensando como novos desenvolvedores podem utilizar estas tecnologias (BEAM, Erlang, Elixir) e creio que escrevendo posso ajudar. Lembrando que a linguagem Elixir foi inventada por um brasileiro, mas se tornou popular fora do Brasil, talvez um blog em Português possa ajudar a comunidade brasileira.</div></div></div><h2 class=f1><a href=/series/beamtools/ class="link blue hover-black">Series: beamtools</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-34/ class="link black dim">BEAM Tools</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">O que é BEAM Tools ? beamtools é um conjunto de software no qual instala versões de Erlang e Elixir prontas para uso. Sem a necessidade de compilar ou instalar mais nada. Disponível para usuários Linux, pode ser uma alternativa os métodos de instalação de Erlang e Elixir.
Atualmente, quando precisamos instalar Erlang ou Elixir vamos ter algumas opções:
usar os pacotes da distribuição Linux. Enquanto a instalação é bem prática e funcional.</div></div></div><h2 class=f1><a href=/series/embedded/ class="link blue hover-black">Series: embedded</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-33/ class="link black dim">Barramentos</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Este post descreve alguns projetos open source onde um desenvolvedor, no qual precisa escrever um software que faz acesso aos barramentos de comunicação entre periféricos, poderia utilizar bibliotecas open source como uma base e evitando gerencia o acesso por ele mesmo ou pelo menos evitar construir algum código desde o começo.
Como um desenvolvedor começa ? Quais são os principais bibliotecas open source ? Estas bibliotecas estão prontas para serem usadas ou precisam de ajustes ou revitalizações ?</div></div></div><h2 class=f1><a href=/series/simulation/ class="link blue hover-black">Series: simulation</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-32/ class="link black dim">Simuladores em Erlang</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Simuladores em Erlang, ideia geral Camadas em software podem ser implementadas para flexibilizar e melhorar o feedback loop durante o desenvolvimento de sistemas que interagem com hardware. Estas camadas podem ser simuladores nos quais, quando ativados, interceptam as chamadas de determinada camada roteando para as APIs simuladas.
O seguinte paper apresenta a ideia geral e motivos do uso de simuladores para desenvolvimento de projetos que interagem com hardware: Erlang Embedded Simulation Thesis Report, segue o abstract do paper:</div></div></div><h2 class=f1><a href=/series/servers/ class="link blue hover-black">Series: servers</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-29/ class="link black dim">Gamepad</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Recentemente comprei uma raspberry pi 4 com o propósito de usar o projeto retropie para jogar video game do século passado. Depois que comprei, lembrei que precisava também comprar controles (gamepads).
Pesquisando na documentação do retropie, verifiquei que existe opções de usar um virtual gamepad e as duas soluções mais usadas são Mobile-Gamepad e Virtual-Gamepad.
Ambas as soluções funcionam do mesmo jeito sendo compostas por:
frontend em javascript simulando um controle e enviando eventos dos botões e direcionais para backend nodejs usando socket.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-26/ class="link black dim">riemann echo</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Vamos detalhar algumas características bem interessante utilizadas na implementação de um servidor riemann chamado katja_echo.
riemann.io riemann.io é um servidor para processamento de stream de eventos, capaz de aplicar funções específicas para cada evento recebido e agregar ou gerar outros eventos para sistemas externos, escrito em Clojure e roda usando a JVM.
riemann pode ser utilizado para processar métricas onde aplicações instrumentadas enviam para um servidor central métricas relacionadas com algo importante ocorrido.</div></div></div><h2 class=f1><a href=/series/observability/ class="link blue hover-black">Series: observability</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-25/ class="link black dim">eclero, coletando métricas</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Nesta série de posts sobre Observability vamos instrumentar e estruturar uma aplicação com o objetivo de estudar as estratégias escolhidas.
O que é Observability Resumidamente, é coletar várias visões internas e externas de uma aplicação e correlacionar posteriormente em um sistema externo.
As aplicações e dependências precisam ser instrumentados para enviarem diferentes visões:
métricas traces logs alertas Observability para BEAM Existem várias bibliotecas e iniciativas quando usamos Elixir/Erlang. Veja uma lista neste link: https://github.</div></div></div><h2 class=f1><a href=/series/erlang-nodes/ class="link blue hover-black">Series: erlang nodes</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-24/ class="link black dim">Brincando com Erlang nodes: cloonix</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Na primeira parte, Brincando com Erlang nodes: eclero criamos uma aplicação básica. Já na segunda parte, Brincando com Erlang nodes: embedded , criamos uma imagem Linux para a aplicação e clero. Na terceira parte, Brincando com Erlang nodes: epmd , apresentamos a solução para o problema do epmd. E agora vem a pergunta, como podemos simular mais nós dentro do ambiente ?</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-23/ class="link black dim">Brincando com Erlang nodes: epmd</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Na primeira parte, Brincando com Erlang nodes: eclero , criamos uma aplicação básica. Já na segunda parte, Brincando com Erlang nodes: embedded , colocamos a aplicação em uma imagem Linux. Agora, o próximo passo é falar sobre o epmd.
Mas antes vamos atualizar a lista dos requisitos:
Cada nó necessita detectar e ser notificado de qualquer falha dos outros nós O cluster de nós Erlang deve ser configurado utilizando algum tipo de configuração vinda do ambiente O ambiente de execução é Linux embarcado rodando em qualquer plataforma Desejável poder rodar em um ambiente embarcado com o mínimo de recursos necessários Mínimo de 3 nós para a solução funcionar epmd epmd: Erlang Portmap Daemon é um daemon no qual conhece o endereço e nomes de todos os nós Erlang de dentro de um cluster.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-22/ class="link black dim">Brincando com Erlang nodes: embedded</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Na primeira parte, Brincando com Erlang nodes: eclero criamos uma aplicação básica. O próximo passo é continuar com o desenvolvimento dos requisitos. Relembrando e incrementando os requisitos, temos:
Cada nó necessita detectar e ser notificado de qualquer falha dos outros nós O cluster de nós Erlang deve ser configurado utilizando algum tipo de configuração vinda do ambiente O ambiente de execução é Linux embarcado rodando em qualquer plataforma Desejável poder rodar em um ambiente embarcado com o mínimo de recursos necessários Mínimo de 3 nós para a solução funcionar Agora vamos abordar alguns assuntos que não são propriamente relacionados com Erlang e Elixir mas fazem parte do contexto dos requisitos.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-20/ class="link black dim">Brincando com Erlang nodes: eclero</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Vamos iniciar alguns trabalhos para explorar como desenvolver, testar e experimentar utilizando nodes Erlang e uma aplicação distribuída.
Na primeira parte dos trabalhos vou contar um pouco sobre o design, detalhes de implementação e testes. A intenção foi implementar uma aplicação simples mas que utilize diversos conceitos e recursos do ambiente podendo ser utilizada para futuras experimentações.</div></div></div><h2 class=f1><a href=/series/documentation/ class="link blue hover-black">Series: documentation</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-19/ class="link black dim">Como documentar e comunicar aplicações OTP</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Documentar um projeto de software com o objetivo de agilizar a comunicação durante o desenvolvimento de um projeto é fundamental para muitas equipes e pode minimizar o tempo de desenvolvimento. Um time alinhado, onde todos saibam como é a arquitetura das soluções, fortalece o senso de ownership.
Mas como podemos documentar a arquitetura de software quando estamos utilizando Erlang ou Elixir? Será que existe algum padrão, diagrama ou técnica?
Este post vai abordar como podemos criar uma documentação efetiva.</div></div></div><h2 class=f1><a href=/series/out-of-band/ class="link blue hover-black">Series: out-of-band</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-21/ class="link black dim">Gerenciamento out-of-band: SSH</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">No primeiro artigo , introduzimos a ideia geral do out-of-band. Neste post vamos continuar e implementar uma outra forma de acesso. Desta vez utilizando um servidor SSH embutido na aplicação.
Geralmente quando precisamos acessar alguma aplicação remotamente, utilizamos o SSH para conectar no servidor e depois podemos utilizar alguma interface de linha de comando no qual conversa com a aplicação ou fazer um &lsquo;attach&rsquo; no node e executar qualquer comando.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-17/ class="link black dim">Gerenciamento out-of-band: SQL</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">A ideia deste post é abordar algumas maneiras de fazer um gerenciamento out-of-band de uma aplicação. E a inspiração veio desta discussão sqlapi: library to connect to your erlang server via SQL:
This library can help you to make an SQL server from your existing server.
For example you have a server and let it be ejabberd. You want to give a list of connected users. Of course you will start from making HTTP endpoint that will reply with JSON with list of users.</div></div></div><h2 class=f1><a href=/series/traces/ class="link blue hover-black">Series: traces</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-16/ class="link black dim">meta-erlang com LTTng</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Neste post vamos ativar o suporte LTTng na BEAM VM usando o projeto Yocto com a layer meta-erlang. O objetivo é demonstrar como podemos fazer a análise de um problema utilizando esta abordagem.
Caso nunca tenha ouvido falar do projeto Yocto, tenha em mente que os conhecimentos usados aqui funcionam para qualquer distribuição Linux.
Basicamente vamos explorar quatro grandes blocos:
BEAM VM, com suporte ao LTTng habilitado Yocto Project, onde vamos usar uma distro básica com Erlang Tracecompass, um plugin do projeto Eclipse para visualização e monitoramento de traces Um código de exemplo em Erlang, apresentando algum problema no qual podemos visualizar com o LTTng.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-15/ class="link black dim">Ativando traces usando LTTng</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Neste post vamos descobrir como podemos instrumentar aplicações Erlang/Elixir dinamicamente.
Trace dinâmicos Um trace dinâmico é um conjunto de bibliotecas nas quais permitem instrumentar partes do sistema em tempo de execução, com o objetivo de extrair métricas de performance, ajudando na resolução de problemas.
Geralmente estes traces possibilitam uma visão fim-a-fim envolvendo a aplicação e chamadas de sistema.
Trace BEAM Existem três modos de utilizar traces dinâmicos no BEAM. Sendo dependente do Sistema Operacional:</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-12/ class="link black dim">Trace instrumentando o código com dbg</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">Este post é sobre como instrumentar uma aplicação e coletar traces para posterior analise. A ideia veio deste post: Erlang trace files in Wireshark e também deste código hackney_trace.erl.
Aqui estamos falando de como utilizar a BEAM VM para capturar traces da aplicação. Podemos usar trace nas seguintes situações:
low level information próprio para debug do software queremos localizar extamente o ponto que ocorre algum evento as informações são destinadas para o desenvolvedor adicionar e remover trace devem ser rápidos Um módulo em Elixir pode ser construído para instrumentar uma aplicação com pontos de trace.</div></div></div><h2 class=f1><a href=/series/vamos-testar/ class="link blue hover-black">Series: vamos testar</a></h2><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-5/ class="link black dim">Vamos testar: exunit</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">ExUnit é o framework padrão quando falamos de testes em Elixir. Ele é simples e ao mesmo tempo poderoso.
Todos os testes em Elixir ficam separados da implementação, geralmente no diretório test. Todos os arquivos teste diretório que seguem o padrão de nome: &lt;nome do teste>_test.exs são compilados e executados como testes pelo comando mix test.
Cada teste é implementado dentro de um módulo normal no usa as macros contidas no ExUnit.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-11/ class="link black dim">Elixir: mocks, stubs</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">As duas abordagens abaixo servem para configurar um projeto para utilizar mocks durante os testes.
Abordagem 1: mocks sem ajuda O arquivo mix.exs deve ser ajustado acrescentando um diretório adicional para a propriedade elixirc_paths:
def project do [app: :coffee_fsm, version: "0.1.0", elixir: "~> 1.4", elixirc_paths: elixirc_paths(Mix.env), build_embedded: Mix.env == :prod, start_permanent: Mix.env == :prod, deps: deps()] end def application do # Specify extra applications you'll use from Erlang/Elixir [extra_applications: [:logger]] end defp elixirc*paths(:test), do: ["lib","test/support"] defp elixirc_paths(*), do: ["lib"] Quando MIX_ENV for test a função elixirc_paths/1 retorna uma lista com dois diretórios onde existe código Elixir para ser compilado.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-9/ class="link black dim">Vamos testar: lux</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">lux é um framework para automação de testes utilizando o estilo Expect (https://en.wikipedia.org/wiki/Expect, https://core.tcl-lang.org/expect/index).
A ideia básica é a definição de um script contendo os comandos usados para testar alguma aplicação e tambem colocando algumas marcações no script que irão controlar o lux.
Este framework provê mecanismos de fazer uma automação de testes, ou seja, aqueles comandos que são utilizados para testar alguma aplicação podem ser escritos em uma forma bem simples nos quais o lux vai controlar a execução.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-4/ class="link black dim">Vamos testar: common_test</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">common_test é uma das aplicações mais interessantes que acompanha a distribuição Erlang/OTP. Digo isso pois os casos de uso que a ferramenta resolve são baseados em casos reais da indústria. Podemos realizar vários tipos de testes, por exemplo:
black-box, utilizando algum protocolo de comunicação: ssh, netconf, telnet, ftp white-box, para testar aplicações escritas em Erlang ou Elixir, fazendo chamadas reais unit tests, há vários projetos que utilizam somente o common_test para implementar todos os testes necessários É possível criar suites de testes com várias formas de execução dos testes e organização.</div></div></div><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/mignon-3/ class="link black dim">Vamos testar: eunit</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">eunit é um framework para testes leves e parte da distribuição Erlang/OTP padrão.
Os testes podem ser definidos dentro de cada módulo, dentro de blocos
-ifdef(EUNIT). % test code here ... -endif. Ou em arquivos separados, geralmente dentro do diretório test, em uma base de código.
A filosofia do framework segue a linha XUnit, mas adaptado para o conceito funcional.
Vejo duas principais vantagens para definir os testes dentro de módulos:</div></div></div></section></div></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://beam-mignon.netlify.app/>&copy; https://creativecommons.org/licenses/by/4.0/ 2023</a><div><div class=ananke-socials><a href=https://twitter.com/joaohf target=_blank class="twitter ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window"><span class=icon><svg style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span></a><a href=https://github.com/joaohf/ target=_blank class="github ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="GitHub link" rel=noopener aria-label="follow on GitHub——Opens in a new window"><span class=icon><svg style="enable-background:new 0 0 512 512" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M256 32C132.3 32 32 134.8 32 261.7c0 101.5 64.2 187.5 153.2 217.9 11.2 2.1 15.3-5 15.3-11.1.0-5.5-.2-19.9-.3-39.1-62.3 13.9-75.5-30.8-75.5-30.8-10.2-26.5-24.9-33.6-24.9-33.6-20.3-14.3 1.5-14 1.5-14 22.5 1.6 34.3 23.7 34.3 23.7 20 35.1 52.4 25 65.2 19.1 2-14.8 7.8-25 14.2-30.7-49.7-5.8-102-25.5-102-113.5.0-25.1 8.7-45.6 23-61.6-2.3-5.8-10-29.2 2.2-60.8.0.0 18.8-6.2 61.6 23.5 17.9-5.1 37-7.6 56.1-7.7 19 .1 38.2 2.6 56.1 7.7 42.8-29.7 61.5-23.5 61.5-23.5 12.2 31.6 4.5 55 2.2 60.8 14.3 16.1 23 36.6 23 61.6.0 88.2-52.4 107.6-102.3 113.3 8 7.1 15.2 21.1 15.2 42.5.0 30.7-.3 55.5-.3 63 0 6.1 4 13.3 15.4 11C415.9 449.1 480 363.1 480 261.7 480 134.8 379.7 32 256 32z"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span></a><a href=https://www.linkedin.com/in/jo%c3%a3o-henrique-freitas target=_blank class="linkedin ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="LinkedIn link" rel=noopener aria-label="follow on LinkedIn——Opens in a new window"><span class=icon><svg style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span></a><a href=https://beam-mignon.netlify.app/feed.xml target=_blank class="rss ananke-social-link link-transition stackoverflow link dib z-999 pt3 pt0-l mr1" title="RSS link" rel=noopener aria-label="follow on RSS——Opens in a new window"><span class=icon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"/><path id="scale" d="M4 4.44v2.83c7.03.0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9.0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/></svg></span><span class=new-window><svg height="8" style="enable-background:new 0 0 1000 1000" viewBox="0 0 1e3 1e3" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M598 128h298v298h-86V274L392 692l-60-60 418-418H598v-86zM810 810V512h86v298c0 46-40 86-86 86H214c-48 0-86-40-86-86V214c0-46 38-86 86-86h298v86H214v596h596z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></span></a></div></div></div></footer></body></html>