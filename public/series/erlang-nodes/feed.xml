<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>erlang nodes on BEAM Mignon</title><link>https://beam-mignon.netlify.app/series/erlang-nodes/</link><description>Recent content in erlang nodes on BEAM Mignon</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><copyright>https://creativecommons.org/licenses/by/4.0/</copyright><lastBuildDate>Sat, 21 Dec 2019 22:45:50 +0200</lastBuildDate><atom:link href="https://beam-mignon.netlify.app/series/erlang-nodes/feed.xml" rel="self" type="application/rss+xml"/><item><title>Brincando com Erlang nodes: cloonix</title><link>https://beam-mignon.netlify.app/posts/mignon-24/</link><pubDate>Sat, 21 Dec 2019 22:45:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-24/</guid><description>Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Na primeira parte, Brincando com Erlang nodes: eclero criamos uma aplicação básica. Já na segunda parte, Brincando com Erlang nodes: embedded , criamos uma imagem Linux para a aplicação e clero. Na terceira parte, Brincando com Erlang nodes: epmd , apresentamos a solução para o problema do epmd. E agora vem a pergunta, como podemos simular mais nós dentro do ambiente ?</description></item><item><title>Brincando com Erlang nodes: epmd</title><link>https://beam-mignon.netlify.app/posts/mignon-23/</link><pubDate>Sat, 21 Dec 2019 22:45:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-23/</guid><description>Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Na primeira parte, Brincando com Erlang nodes: eclero , criamos uma aplicação básica. Já na segunda parte, Brincando com Erlang nodes: embedded , colocamos a aplicação em uma imagem Linux. Agora, o próximo passo é falar sobre o epmd.
Mas antes vamos atualizar a lista dos requisitos:
Cada nó necessita detectar e ser notificado de qualquer falha dos outros nós O cluster de nós Erlang deve ser configurado utilizando algum tipo de configuração vinda do ambiente O ambiente de execução é Linux embarcado rodando em qualquer plataforma Desejável poder rodar em um ambiente embarcado com o mínimo de recursos necessários Mínimo de 3 nós para a solução funcionar epmd epmd: Erlang Portmap Daemon é um daemon no qual conhece o endereço e nomes de todos os nós Erlang de dentro de um cluster.</description></item><item><title>Brincando com Erlang nodes: embedded</title><link>https://beam-mignon.netlify.app/posts/mignon-22/</link><pubDate>Fri, 20 Dec 2019 22:45:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-22/</guid><description>Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Na primeira parte, Brincando com Erlang nodes: eclero criamos uma aplicação básica. O próximo passo é continuar com o desenvolvimento dos requisitos. Relembrando e incrementando os requisitos, temos:
Cada nó necessita detectar e ser notificado de qualquer falha dos outros nós O cluster de nós Erlang deve ser configurado utilizando algum tipo de configuração vinda do ambiente O ambiente de execução é Linux embarcado rodando em qualquer plataforma Desejável poder rodar em um ambiente embarcado com o mínimo de recursos necessários Mínimo de 3 nós para a solução funcionar Agora vamos abordar alguns assuntos que não são propriamente relacionados com Erlang e Elixir mas fazem parte do contexto dos requisitos.</description></item><item><title>Brincando com Erlang nodes: eclero</title><link>https://beam-mignon.netlify.app/posts/mignon-20/</link><pubDate>Thu, 05 Dec 2019 22:43:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-20/</guid><description>Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Vamos iniciar alguns trabalhos para explorar como desenvolver, testar e experimentar utilizando nodes Erlang e uma aplicação distribuída.
Na primeira parte dos trabalhos vou contar um pouco sobre o design, detalhes de implementação e testes. A intenção foi implementar uma aplicação simples mas que utilize diversos conceitos e recursos do ambiente podendo ser utilizada para futuras experimentações.</description></item></channel></rss>