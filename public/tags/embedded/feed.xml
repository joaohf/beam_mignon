<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>embedded on BEAM Mignon</title><link>https://beam-mignon.netlify.app/tags/embedded/</link><description>Recent content in embedded on BEAM Mignon</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><copyright>https://creativecommons.org/licenses/by/4.0/</copyright><lastBuildDate>Fri, 20 Dec 2019 22:45:50 +0200</lastBuildDate><atom:link href="https://beam-mignon.netlify.app/tags/embedded/feed.xml" rel="self" type="application/rss+xml"/><item><title>Brincando com Erlang nodes: embedded</title><link>https://beam-mignon.netlify.app/posts/mignon-22/</link><pubDate>Fri, 20 Dec 2019 22:45:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-22/</guid><description>Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Na primeira parte, Brincando com Erlang nodes: eclero criamos uma aplicação básica. O próximo passo é continuar com o desenvolvimento dos requisitos. Relembrando e incrementando os requisitos, temos:
Cada nó necessita detectar e ser notificado de qualquer falha dos outros nós O cluster de nós Erlang deve ser configurado utilizando algum tipo de configuração vinda do ambiente O ambiente de execução é Linux embarcado rodando em qualquer plataforma Desejável poder rodar em um ambiente embarcado com o mínimo de recursos necessários Mínimo de 3 nós para a solução funcionar Agora vamos abordar alguns assuntos que não são propriamente relacionados com Erlang e Elixir mas fazem parte do contexto dos requisitos.</description></item></channel></rss>