<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>code on BEAM Mignon</title><link>https://beam-mignon.netlify.app/tags/code/</link><description>Recent content in code on BEAM Mignon</description><generator>Hugo -- gohugo.io</generator><language>pt-br</language><copyright>https://creativecommons.org/licenses/by/4.0/</copyright><lastBuildDate>Mon, 26 Sep 2022 21:00:00 +0200</lastBuildDate><atom:link href="https://beam-mignon.netlify.app/tags/code/feed.xml" rel="self" type="application/rss+xml"/><item><title>Barramentos</title><link>https://beam-mignon.netlify.app/posts/mignon-33/</link><pubDate>Mon, 26 Sep 2022 21:00:00 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-33/</guid><description>Este post descreve alguns projetos open source onde um desenvolvedor, no qual precisa escrever um software que faz acesso aos barramentos de comunicação entre periféricos, poderia utilizar bibliotecas open source como uma base e evitando gerencia o acesso por ele mesmo ou pelo menos evitar construir algum código desde o começo.
Como um desenvolvedor começa ? Quais são os principais bibliotecas open source ? Estas bibliotecas estão prontas para serem usadas ou precisam de ajustes ou revitalizações ?</description></item><item><title>Simuladores em Erlang</title><link>https://beam-mignon.netlify.app/posts/mignon-32/</link><pubDate>Sun, 30 Jan 2022 21:46:00 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-32/</guid><description>Simuladores em Erlang, ideia geral Camadas em software podem ser implementadas para flexibilizar e melhorar o feedback loop durante o desenvolvimento de sistemas que interagem com hardware. Estas camadas podem ser simuladores nos quais, quando ativados, interceptam as chamadas de determinada camada roteando para as APIs simuladas.
O seguinte paper apresenta a ideia geral e motivos do uso de simuladores para desenvolvimento de projetos que interagem com hardware: Erlang Embedded Simulation Thesis Report, segue o abstract do paper:</description></item><item><title>Aplicações distribuídas com OTP</title><link>https://beam-mignon.netlify.app/posts/mignon-31/</link><pubDate>Sun, 03 Oct 2021 21:46:00 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-31/</guid><description>Distributed applications O conceito de distributed applications em Erlang/OTP segue a ideia de que determinada aplicação executa em um determinado nó de um cluster. Se a aplicação parar por alguma falha, então a aplicação vai ser iniciada em outro nó.
Isso não quer dizer que a aplicação vai estar rodando em todos os nós ao mesmo tempo. Mas sim em apenas um determinado nó (de maior prioridade configurada).
O que vai estar rodando e ativamente controlando a aplicação é o _distributed application controller.</description></item><item><title>Gamepad</title><link>https://beam-mignon.netlify.app/posts/mignon-29/</link><pubDate>Fri, 28 Aug 2020 22:43:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-29/</guid><description>Recentemente comprei uma raspberry pi 4 com o propósito de usar o projeto retropie para jogar video game do século passado. Depois que comprei, lembrei que precisava também comprar controles (gamepads).
Pesquisando na documentação do retropie, verifiquei que existe opções de usar um virtual gamepad e as duas soluções mais usadas são Mobile-Gamepad e Virtual-Gamepad.
Ambas as soluções funcionam do mesmo jeito sendo compostas por:
frontend em javascript simulando um controle e enviando eventos dos botões e direcionais para backend nodejs usando socket.</description></item><item><title>riemann echo</title><link>https://beam-mignon.netlify.app/posts/mignon-26/</link><pubDate>Sun, 26 Jul 2020 22:43:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-26/</guid><description>Vamos detalhar algumas características bem interessante utilizadas na implementação de um servidor riemann chamado katja_echo.
riemann.io riemann.io é um servidor para processamento de stream de eventos, capaz de aplicar funções específicas para cada evento recebido e agregar ou gerar outros eventos para sistemas externos, escrito em Clojure e roda usando a JVM.
riemann pode ser utilizado para processar métricas onde aplicações instrumentadas enviam para um servidor central métricas relacionadas com algo importante ocorrido.</description></item><item><title>eclero, coletando métricas</title><link>https://beam-mignon.netlify.app/posts/mignon-25/</link><pubDate>Wed, 29 Jan 2020 18:43:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-25/</guid><description>Nesta série de posts sobre Observability vamos instrumentar e estruturar uma aplicação com o objetivo de estudar as estratégias escolhidas.
O que é Observability Resumidamente, é coletar várias visões internas e externas de uma aplicação e correlacionar posteriormente em um sistema externo.
As aplicações e dependências precisam ser instrumentados para enviarem diferentes visões:
métricas traces logs alertas Observability para BEAM Existem várias bibliotecas e iniciativas quando usamos Elixir/Erlang. Veja uma lista neste link: https://github.</description></item><item><title>Brincando com Erlang nodes: cloonix</title><link>https://beam-mignon.netlify.app/posts/mignon-24/</link><pubDate>Sat, 21 Dec 2019 22:45:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-24/</guid><description>Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Na primeira parte, Brincando com Erlang nodes: eclero criamos uma aplicação básica. Já na segunda parte, Brincando com Erlang nodes: embedded , criamos uma imagem Linux para a aplicação e clero. Na terceira parte, Brincando com Erlang nodes: epmd , apresentamos a solução para o problema do epmd. E agora vem a pergunta, como podemos simular mais nós dentro do ambiente ?</description></item><item><title>Brincando com Erlang nodes: epmd</title><link>https://beam-mignon.netlify.app/posts/mignon-23/</link><pubDate>Sat, 21 Dec 2019 22:45:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-23/</guid><description>Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Na primeira parte, Brincando com Erlang nodes: eclero , criamos uma aplicação básica. Já na segunda parte, Brincando com Erlang nodes: embedded , colocamos a aplicação em uma imagem Linux. Agora, o próximo passo é falar sobre o epmd.
Mas antes vamos atualizar a lista dos requisitos:
Cada nó necessita detectar e ser notificado de qualquer falha dos outros nós O cluster de nós Erlang deve ser configurado utilizando algum tipo de configuração vinda do ambiente O ambiente de execução é Linux embarcado rodando em qualquer plataforma Desejável poder rodar em um ambiente embarcado com o mínimo de recursos necessários Mínimo de 3 nós para a solução funcionar epmd epmd: Erlang Portmap Daemon é um daemon no qual conhece o endereço e nomes de todos os nós Erlang de dentro de um cluster.</description></item><item><title>Brincando com Erlang nodes: embedded</title><link>https://beam-mignon.netlify.app/posts/mignon-22/</link><pubDate>Fri, 20 Dec 2019 22:45:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-22/</guid><description>Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Na primeira parte, Brincando com Erlang nodes: eclero criamos uma aplicação básica. O próximo passo é continuar com o desenvolvimento dos requisitos. Relembrando e incrementando os requisitos, temos:
Cada nó necessita detectar e ser notificado de qualquer falha dos outros nós O cluster de nós Erlang deve ser configurado utilizando algum tipo de configuração vinda do ambiente O ambiente de execução é Linux embarcado rodando em qualquer plataforma Desejável poder rodar em um ambiente embarcado com o mínimo de recursos necessários Mínimo de 3 nós para a solução funcionar Agora vamos abordar alguns assuntos que não são propriamente relacionados com Erlang e Elixir mas fazem parte do contexto dos requisitos.</description></item><item><title>Brincando com Erlang nodes: eclero</title><link>https://beam-mignon.netlify.app/posts/mignon-20/</link><pubDate>Thu, 05 Dec 2019 22:43:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-20/</guid><description>Este post faz parte de uma série de outros posts relacionados a como usar Erlang distribution protocol.
Vamos iniciar alguns trabalhos para explorar como desenvolver, testar e experimentar utilizando nodes Erlang e uma aplicação distribuída.
Na primeira parte dos trabalhos vou contar um pouco sobre o design, detalhes de implementação e testes. A intenção foi implementar uma aplicação simples mas que utilize diversos conceitos e recursos do ambiente podendo ser utilizada para futuras experimentações.</description></item><item><title>Gerenciamento out-of-band: SSH</title><link>https://beam-mignon.netlify.app/posts/mignon-21/</link><pubDate>Sat, 21 Sep 2019 22:43:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-21/</guid><description>No primeiro artigo , introduzimos a ideia geral do out-of-band. Neste post vamos continuar e implementar uma outra forma de acesso. Desta vez utilizando um servidor SSH embutido na aplicação.
Geralmente quando precisamos acessar alguma aplicação remotamente, utilizamos o SSH para conectar no servidor e depois podemos utilizar alguma interface de linha de comando no qual conversa com a aplicação ou fazer um &amp;lsquo;attach&amp;rsquo; no node e executar qualquer comando.</description></item><item><title>Gerenciamento out-of-band: SQL</title><link>https://beam-mignon.netlify.app/posts/mignon-17/</link><pubDate>Sat, 14 Sep 2019 22:43:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-17/</guid><description>A ideia deste post é abordar algumas maneiras de fazer um gerenciamento out-of-band de uma aplicação. E a inspiração veio desta discussão sqlapi: library to connect to your erlang server via SQL:
This library can help you to make an SQL server from your existing server.
For example you have a server and let it be ejabberd. You want to give a list of connected users. Of course you will start from making HTTP endpoint that will reply with JSON with list of users.</description></item><item><title>meta-erlang com LTTng</title><link>https://beam-mignon.netlify.app/posts/mignon-16/</link><pubDate>Wed, 11 Sep 2019 22:43:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-16/</guid><description>Neste post vamos ativar o suporte LTTng na BEAM VM usando o projeto Yocto com a layer meta-erlang. O objetivo é demonstrar como podemos fazer a análise de um problema utilizando esta abordagem.
Caso nunca tenha ouvido falar do projeto Yocto, tenha em mente que os conhecimentos usados aqui funcionam para qualquer distribuição Linux.
Basicamente vamos explorar quatro grandes blocos:
BEAM VM, com suporte ao LTTng habilitado Yocto Project, onde vamos usar uma distro básica com Erlang Tracecompass, um plugin do projeto Eclipse para visualização e monitoramento de traces Um código de exemplo em Erlang, apresentando algum problema no qual podemos visualizar com o LTTng.</description></item><item><title>Ativando traces usando LTTng</title><link>https://beam-mignon.netlify.app/posts/mignon-15/</link><pubDate>Mon, 09 Sep 2019 21:33:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-15/</guid><description>Neste post vamos descobrir como podemos instrumentar aplicações Erlang/Elixir dinamicamente.
Trace dinâmicos Um trace dinâmico é um conjunto de bibliotecas nas quais permitem instrumentar partes do sistema em tempo de execução, com o objetivo de extrair métricas de performance, ajudando na resolução de problemas.
Geralmente estes traces possibilitam uma visão fim-a-fim envolvendo a aplicação e chamadas de sistema.
Trace BEAM Existem três modos de utilizar traces dinâmicos no BEAM. Sendo dependente do Sistema Operacional:</description></item><item><title>Trace instrumentando o código com dbg</title><link>https://beam-mignon.netlify.app/posts/mignon-12/</link><pubDate>Sat, 17 Aug 2019 12:15:50 +0200</pubDate><guid>https://beam-mignon.netlify.app/posts/mignon-12/</guid><description>Este post é sobre como instrumentar uma aplicação e coletar traces para posterior analise. A ideia veio deste post: Erlang trace files in Wireshark e também deste código hackney_trace.erl.
Aqui estamos falando de como utilizar a BEAM VM para capturar traces da aplicação. Podemos usar trace nas seguintes situações:
low level information próprio para debug do software queremos localizar extamente o ponto que ocorre algum evento as informações são destinadas para o desenvolvedor adicionar e remover trace devem ser rápidos Um módulo em Elixir pode ser construído para instrumentar uma aplicação com pontos de trace.</description></item></channel></rss>